# 비관적 락 (Pessimistic Lock)

## 개념

비관적 락은 "충돌이 발생할 것이다" 라고 **비관적으로** 가정하고, 데이터에 접근하기 전에 미리 잠금을 거는 방식이다. 다른 트랜잭션이 해당 데이터에 접근하려면 잠금이 해제될 때까지 대기해야 한다.

## 작동 원리

1. 트랜잭션이 시작될 때 데이터에 잠금을 설정
2. 잠금이 설정된 데이터는 다른 트랜잭션이 수정할수 없음
3. 트랜잭션이 완료(커밋 또는 롤백)되면 잠금을 해제
4. 다른 트랜잭션은 대기 상태에서 잠금이 해제되면 작업 진행

## 비관적 락의 종류

1. 공유 락(Shared Lock / Read Lock) : 데이터 읽기만 허용
2. 배타적 락(Exclusive Lock / Write Lock) : 읽기와 쓰기 모두 제한

## 장점

1. 데이터 일관성 보장 : 동시성 문제 원천 차단
2. 실시간 시스템에 적합 : 충돌 복구 로직이 필요 없음
3. 예측 가능성 : 성능이 예측 가능하고 일관적
4. 트랜잭션 충동 방지 : 동시 수정으로 인한 데이터 불일치 방지
5. 실시간 시스템에 적합 : 충돌 복구 로직이 필요 없음

## 단점

1. 성능 오버헤드 : 잠금 획득/해제 과정이 필요
2. 확장성 제한 : 동시 요청이 많을수록 대기 시간 증가
3. 데드락 가능성 : 복잡한 시스템에서 교착 상태 발생 가능
4. 자원 소모 : 락 관리에 시스템 자원 사용

## 적합한 사용 사례

1. 높은 충돌 가능성 : 같은 데이터를 여러 사용자가 동시에 수정하는 환경
2. 금융 트랜잭션 : 계좌 이체와 같이 정확성이 매우 중요한 작업
3. 재고 관리 시스템 : 동시 주문으로 인한 초과 판매 방지 필요
4. 예약 시스템 : 동일 자리/시간대에 대한 중복 예약 방지

## JPA에서의 비관적 락 구현 예제

```java
public interface EntityRepository extends JpaRepository<Entity, Long> {
	// 읽기 잠금 (공유 락)
	@Lock(LockModeType.PESSIMISTIC_READ)
	@Query("SELECT e FROM Entity e WHERE e.id = :id")
	Optional<Entity> findByIdWithReadLock(@Param("id") Long id);

	// 쓰기 잠금 (배타적 락)
	@Lock(LockModeType.PESSIMISTIC_WRITE)
	@Query("SELECT e FROM Entity e WHERE e.id = :id")
	Optional<Entity> findByIdWithWriteLock(@Param("id") Long id);

	// 쓰기 잠금 (Force Increment)
	@Lock(LockModeType.PESSIMISTIC_FORCE_INCREMENT)
	@Query("SELECT e FROM Entity e WHERE e.id = :id")
	Optional<Entity> findByIdWithForceIncrementLock(@Param("id") Long id);
}
```

## 유의사항

1. **락 범위 최소화**: 필요한 데이터만 잠그도록 설계
2. **타임아웃 설정**: 락 획득 대기 시간 제한하여 무한 대기 방지
3. **데드락 방지**: 항상 같은 순서로 락을 획득하도록 설계
4. **트랜잭션 범위 최소화**: 잠금 시간 최소화
5. **에러 처리 철저**: 예외 발생 시에도 락이 해제되도록 처리

---

# 2. 낙관적 락(Optimistic Lock)

## 개념

낙관적 락은 "충돌이 거의 발생하지 않을 것이다"라고 **낙관적으로** 가정하는 방식이다. 데이터 읽기 시점에는 잠금을 설정하지 않고, 데이터 수정 시점(커밋)에 충돌 여부를 확인한다.

## 작동 원리

1. 데이터에 버전 정보(또는 타임스탬프) 추가
2. 데이터 읽을 때 현재 버전 값을 함께 읽음
3. 데이터 수정 시 현재 DB의 버전과 읽었던 버전 비교
4. 버전이 다르면 다른 트랜잭션이 데이터를 수정한 것으로 판단하고 충돌 발생
5. 충돌 시 예외를 발생시키거나 재시도 로직 수행

## 장점

1. **높은 동시성**: 락 획득을 기다리지 않아 처리량 증가
2. **데드락 없음**: 명시적 잠금이 없어 교착 상태 발생하지 않음
3. **확장성**: 많은 동시 사용자 지원에 유리
4. **자원 효율성**: 락 관리 오버헤드 없음

## 단점

1. **충돌 처리 필요**: 충돌 발생 시 롤백 및 재시도 로직 구현 필요
2. **충돌 빈도 높은 환경에서 비효율적**: 잦은 충돌 시 재시도로 인한 성능 저하
3. **복잡한 에러 처리**: 사용자 경험을 위한 충돌 해결 UI 필요

## 적합한 사용 사례

1. **읽기 위주 애플리케이션**: 데이터 조회가 많고 수정이 적은 환경
2. **충돌 가능성 낮은 환경**: 같은 데이터를 여러 사용자가 수정할 가능성이 낮은 경우
3. **장시간 트랜잭션**: 데이터를 오래 보유하지만 수정은 적은 경우
4. **높은 확장성 요구**: 대규모 사용자 지원이 필요한 웹 애플리케이션

## JPA에서의 낙관적 락 구현 예제

```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int stock;

    @Version  // 낙관적 락을 위한 버전 필드
    private Long version;

    // 메서드 등 생략
}
```

```java
@Service
@Transactional
public class ProductService {
    private final ProductRepository productRepository;

    // 생성자 등 생략

    public void updateStock(Long productId, int quantity) {
        try {
            Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException(productId));

            product.decreaseStock(quantity);

            productRepository.save(product);
        } catch (ObjectOptimisticLockingFailureException e) {
            // 충돌 발생 시 처리 로직
            // 예: 재시도 또는 사용자에게 충돌 알림
        }
    }
}
```

## 유의사항

1. **적절한 버전 관리 필드 선택**: 버전 번호, 타임스탬프 등
2. **충돌 감지 범위 설정**: 엔티티 전체 또는 특정 필드만
3. **충돌 해결 전략 수립**: 자동 재시도, 사용자 개입 요청 등
4. **트랜잭션 분리**: 큰 트랜잭션보다 작은 트랜잭션으로 분리
5. **테스트 철저**: 동시성 시나리오에 대한 테스트 필수

# 3. 비교: 비관적 락 vs 낙관적 락

## 성능 측면

- **낮은 충돌 환경**: 낙관적 락이 유리 (락 오버헤드 없음)
- **높은 충돌 환경**: 비관적 락이 유리 (재시도 오버헤드 없음)

## 구현 복잡성

- **비관적 락**: 데이터베이스 기능에 의존하여 구현 상대적으로 간단
- **낙관적 락**: 충돌 감지 및 해결 로직을 직접 구현해야 함

## 사용자 경험

- **비관적 락**: 대기 시간 발생 가능 (락 획득까지 대기)
- **낙관적 락**: 충돌 시 사용자에게 알림 필요 (재시도 또는 병합)

## 환경별 선택 가이드

1. **대규모 웹 애플리케이션**: 일반적으로 낙관적 락
2. **금융, 예약 시스템**: 일반적으로 비관적 락
3. **멀티테넌트 SaaS**: 테넌트별 데이터는 낙관적 락, 공유 데이터는 비관적 락
4. **마이크로서비스**: 서비스 경계를 넘는 경우 분산 락 또는 낙관적 락
## 4. 고급 주제 및 특수 상황

## 분산 환경에서의 락

1. **분산 락**: Redis, ZooKeeper 등 외부 서비스 활용
2. **애플리케이션 수준 락**: 데이터베이스에 의존하지 않는 락 구현
3. **이벤트 소싱 및 CQRS**: 명령과 쿼리 분리로 동시성 문제 해결

## 특수 상황별 전략

1. **대량 데이터 처리**: 배치 처리 + 낙관적 락
2. **실시간 협업 도구**: 작동 변환(OT) 또는 충돌 없는 복제 데이터 타입(CRDT)
3. **인벤토리 관리**: 초기에는 낙관적 락, 임계치 이하에서 비관적 락으로 전환

# 5. 실제 프로젝트 적용 시 체크리스트

## 비관적 락 도입 체크리스트

- [ ]  트랜잭션 타임아웃 적절히 설정
- [ ]  락 획득 제한 시간(timeout) 설정
- [ ]  데드락 방지 전략 수립
- [ ]  락 범위 최소화 확인
- [ ]  락 획득 실패 시 대체 흐름 구현

## 낙관적 락 도입 체크리스트

- [ ]  버전 관리 필드 선택 및 설계
- [ ]  충돌 감지 시 사용자 피드백 설계
- [ ]  자동 재시도 메커니즘 구현
- [ ]  충돌 빈도 모니터링 방안 수립
- [ ]  낙관적 락 실패 로그 및 분석 체계 구축