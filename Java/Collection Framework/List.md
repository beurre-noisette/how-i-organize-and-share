`List`는 `Collection`을 상속받는 `interface`이며 구현체로는 `ArrayList`, `Vector`, `LinkedList`가 있다. `List`의 가장 큰 특징은 **순서를 유지하며 저장하고, 중복 저장이 가능**하다는 점이다.

### ArrayList

`ArrayList`는 가장 자주 쓰이는 `List`의 구현체로써 내부 배열에 객체가 저장되는 식이다. 일반 배열과의 차이점은 **제한 없이 객체를 추가할 수 있다는 점**이다. 또한 `List` 컬렉션은 객체 자체를 저장하는 것이 아니라 **객체의 번지(메모리의 주소값)** 을 저장한다.

`ArrayList`는 연속된 메모리 공간을 사용한다는 특징이 있다. 이러한 특징으로 인해... **인덱스를 통한 빠른 접근(빠른 탐색)** 이 가능하고, 데이터를 추가, 삭제 할 경우 변동이 있는 데이터의 인덱스가 밀리거나 당겨진다. `ArrayList`가 연속된 메모리 공간을 갖는다고 하였는데, 그 크기는 어떻게 관리될까? `ArrayList`는 선언될 경우 기본적으로 **10**의 크기를 갖는다. 이는 `ArrayList` 클래스에 상수(`DEFAULT_CAPACITY`)로 정의되어 있다. 그리고 이 기본 크기를 넘어가는 코드가 실행될 경우 JVM에 의해 해당 `ArrayList`는 새로운 크기를  갖는 새로운 객체를 생성하며 새로운 크기는 **생성된 `ArrayList` 크기의 1.5배** 씩 증가한다.[^1][^2]

### LinkedList

앞서 `ArrayList`의 가장 큰 특징은 **연속된 메모리 공간을 사용한다**는 점이었다. 그러나 이러한 특징으로 인해 객체에 값이 변동되는 경우(추가나 삭제)가 잦다면 성능이 좋지 않을 수 있는데 이럴 때 사용을 고려해봄직한게 `LinkedList`이다. `LinkedList`는 `ArrayList`와 사용 방법이 동일하지만, **인접 객체를 체인처럼 연결해서 관리한다(노드 구조)** 는 특징을 갖는다. 이게 무슨 말이냐면 메모리의 공간을 통으로 점유하는 것이 아니라, 이름 그대로 자신을 기준으로 앞 뒤 객체의 주소값을 참조하는 방식으로 `List`가 구성되어 있는 것이다. 각 노드는 독립적인 메모리 공간에 생성되고 필요에 의해 새로운 노드를 생성하고 연결하는 방식인 것이다. 이러한 특징으로 인해 `ArrayList`처럼 **resize**의 개념이 없다. 다만 노드 구조의 특징으로 인해 `ArrayList`보다 탐색 시간이 오래걸린다.[^3]

### 그렇다면?

두 컬렉션 프레임워크는 상황에 맞게 활용할 수 있다.
1. 탐색이 빈번한 경우에는 인덱스를 통해 빠른 탐색이 가능한 `ArrayList`구조를 사용한다.
2. 데이터의 삽입과 삭제가 빈번할 경우에는 노드 구조의 `LinkedList`구조를 사용한다.


[^1]: `ArrayList`클래스 내부를 보면 상수 `DAFAULT_CAPACITY`가 10으로 정의되어 있고, 이를 `ArrayList`는 기본 크기로 설정한다. `ArrayList`는 **현재 용량을 기준으로 1.5배 씩 증가한다**. 또한 크기가 증가함에 있어 **비트 연산**에 의해 소수점은 버려진다. `ArrayList`의 `grow` 메서드 참고.
[^2]: 크기를 늘리는 것은 JVM에 의해 자동적으로 진행하지만 삭제는 자동으로 진행하지 않고, 늘어난 크기를 그대로 유지한다.  크기를 줄이고 싶다면 `trimToSize()`메서드를 호출하여 **현재 용량에 딱 맞게** 크기를 줄일 수 있다. 이후에 다시 크기가 늘어날 경우에는 **현재 용량을 기준으로 1.5배씩 증가한다**.
[^3]: 순차적 접근을 해야하기 때문. 시간복잡도는 O(n)